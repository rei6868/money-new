# Linked Transactions Schema

The Linked Transactions table normalises how the platform groups together related ledger entries. It powers refund chains, split payments, batch postings, and settlement workflows where multiple transactions must be evaluated as a unit.

## Drizzle ORM Definition

```ts
import { linkedTransactions } from "@/db/schema/transactions";
```

See [`src/db/schema/transactions.ts`](../src/db/schema/transactions.ts) for inline commentary and implementation specifics.

## Field Reference

| Field | Type | Required | Business Logic & Purpose |
|-------|------|----------|---------------------------|
| `linkedTxnId` | `varchar(36)` | ✅ | Primary key for the grouped transaction set. Supports UUIDs or externally sourced identifiers so integrations can deterministically address the linkage. |
| `parentTxnId` | `varchar(36)` FK → `transactions.transaction_id` | ⛔️ (optional) | Root transaction anchoring the workflow (e.g., original charge for a refund, seed transaction for a split). Null when the group has no natural parent. Uses `SET NULL` so child records survive if the parent is removed. |
| `type` | `linked_txn_type` enum | ✅ | Enumerates the business scenario represented: `refund`, `split`, `batch`, or `settle`. Drives downstream automation decisions for reconciliation logic. |
| `relatedTxnIds` | `varchar(36)[]` | ✅ | Array of all transactions participating in the grouping. Stored as a text array to maintain referential alignment with the transactions ledger while allowing fast membership checks. |
| `status` | `linked_txn_status` enum | ✅ | Lifecycle marker for the group: `active` (in-flight workflow), `done` (complete), or `canceled` (aborted). Deterministic state keeps reconciliation and UI flows consistent. |
| `notes` | `text` | ⛔️ (optional) | Operational remarks or human context for the linkage (e.g., refund reason, settlement memo). |
| `createdAt` | `timestamptz` (default `now()`) | ✅ | Timestamp of when the linkage was created. Supports chronological investigations and sync windows. |
| `updatedAt` | `timestamptz` (default `now()`) | ✅ | Last modification timestamp. Should be updated whenever membership, status, or metadata change to preserve audit accuracy. |

## Multi-step Operations

Linked groups act as the orchestration backbone for workflows that cannot be represented by a single transaction row. Common examples include:

- **Refund Journeys** – `parentTxnId` points at the original charge while `relatedTxnIds` contains the refund leg(s) and any intermediary adjustments.
- **Bill Splits** – `parentTxnId` references the consolidated charge and `relatedTxnIds` enumerates each participant's share transaction.
- **Batch Imports** – groups all ledger entries generated by a bulk import job, enabling atomic status transitions and simplified rollbacks.
- **Settlement Runs** – captures payouts or settlements across parties, letting the platform monitor the group through to completion with the `settle` type.

When building multi-step logic, always:

1. Create the `linked_transactions` row first so individual ledger entries can reference the `linkedTxnId` during insertion.
2. Populate `relatedTxnIds` with every participating transaction ID to maintain traceability and enable downstream analytics.
3. Update `status` from `active` to `done` (or `canceled`) once the workflow completes, ensuring reports and UI badges accurately reflect state.

Following this pattern keeps complex transaction flows auditable while preventing denormalised metadata from leaking into the core `transactions` table.
